
# The Programming Mastery Checklist

As a programmer, one encounters complex concepts that are fundamental to understanding and developing quick, efficient, and secure software. However, on a bareminimum functional standpoint it is easy to overlook these concepts after learning them once in your class. Especially with the wealth of resources and generative ai available online that can help one practically fill out the gaps in knowledge. However, it is crucial to understand programming, and on a broader sense, computers, to excel as a programmer.

To be clear, this resource is not to learn the concepts from scratch, but to review and bolster one's understanding, so a level of competency can be maintained at any given time. To make the challenge more compelelling, try finishing, all the exercises in a terminal environment.

## 1. Data Structures Mastery

### Arrays, Linked Lists, Stacks, and Queues
- [ ] Implement arrays from scratch (static and dynamic).
- [ ] Implement singly, doubly, and circular linked lists.
- [ ] Understand memory management in linked lists.
- [ ] Implement stack and queue using arrays and linked lists.
- [ ] Study time complexity of common operations (push, pop, enqueue, dequeue).

### Binary Trees, Heaps, and Balanced Trees
- [ ] Implement Binary Trees and Binary Search Trees (BST).
- [ ] Understand tree traversals (inorder, preorder, postorder).
- [ ] Implement AVL Trees with self-balancing rotations.
- [ ] Implement Heaps (Min and Max) and perform heapify operations.
- [ ] Be comfortable with insertion and deletion in Binary Search Trees.

### Graph Data Structures
- [ ] Implement graphs using adjacency lists and adjacency matrices.
- [ ] Understand different graph types (directed, undirected, weighted).
- [ ] Implement Depth-First Search (DFS) and Breadth-First Search (BFS).
- [ ] Understand graph traversal time and space complexities.
- [ ] Implement algorithms for cycle detection and connected components.

### Hash Tables and Tries
- [ ] Implement a hash table with separate chaining and open addressing.
- [ ] Understand hash functions and collision resolution techniques.
- [ ] Implement a Trie for fast prefix-based searching.
- [ ] Practice adding and searching for keys in Tries.

## 2. Algorithmic Techniques

### Sorting Algorithms
- [ ] Implement Merge Sort, Quick Sort, and Heap Sort from scratch.
- [ ] Understand stability and in-place sorting techniques.
- [ ] Analyze time and space complexities of each sorting algorithm.
- [ ] Handle edge cases in sorting algorithms (already sorted, reverse sorted).

### Recursion and Divide and Conquer
- [ ] Practice designing recursive algorithms.
- [ ] Understand and implement base cases and recursive cases properly.
- [ ] Implement recursive algorithms for problems like Binary Search and Merge Sort.
- [ ] Convert recursive solutions to iterative solutions.

### Dynamic Programming
- [ ] Understand principles of memoization and tabulation.
- [ ] Implement classical problems like Knapsack, Longest Increasing Subsequence, and Fibonacci.
- [ ] Recognize common DP patterns (subset, knapsack, etc.).
- [ ] Optimize dynamic programming solutions for time and space.

### Graph Algorithms
- [ ] Implement Dijkstra’s algorithm for shortest path.
- [ ] Implement Bellman-Ford and Floyd-Warshall algorithms.
- [ ] Implement Prim’s and Kruskal’s Minimum Spanning Tree algorithms.
- [ ] Be able to code Strongly Connected Components and topological sorting.
- [ ] Practice implementing graph traversal in a parallelizable manner.

## 3. Parallel Programming

### OpenMP Fundamentals
- [ ] Understand thread-based parallelism and OpenMP pragmas.
- [ ] Implement parallel loops and sections using OpenMP.
- [ ] Implement reductions and handle race conditions using synchronization.
- [ ] Optimize parallel Merge Sort using OpenMP.

### MPI for Distributed Computing
- [ ] Implement simple MPI programs (point-to-point communication).
- [ ] Understand collective communication (broadcasting, scattering, gathering, reduction).
- [ ] Practice load balancing and optimizing communication overhead.
- [ ] Implement parallel matrix multiplication using MPI.

### CUDA Fundamentals
- [ ] Understand GPU architecture and CUDA cores.
- [ ] Write simple CUDA programs and implement parallel algorithms.
- [ ] Handle memory transfers between CPU and GPU.
- [ ] Optimize kernel performance by using shared memory and minimizing memory divergence.

## 4. Memory Management and Pointers

### Pointers and Memory Management
- [ ] Understand stack vs heap memory allocation.
- [ ] Implement pointer-based data structures (linked lists, trees).
- [ ] Manage dynamic memory using malloc, free, new, and delete.
- [ ] Understand and avoid common pitfalls (dangling pointers, memory leaks).

### Cache Optimization
- [ ] Study how cache works and implement cache-friendly algorithms.
- [ ] Optimize memory access patterns for CPU caches.
- [ ] Handle cache coherence in multi-core systems.
